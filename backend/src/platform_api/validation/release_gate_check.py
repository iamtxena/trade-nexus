"""Release preflight checker for validation replay merge/release gates."""

from __future__ import annotations

import argparse
import asyncio
import json
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Literal

from src.platform_api.schemas_v1 import RequestContext
from src.platform_api.schemas_v2 import (
    CreateValidationBaselineRequest,
    CreateValidationRegressionReplayRequest,
    CreateValidationRunRequest,
    ValidationRegressionReplay,
)
from src.platform_api.services.validation_identity_service import ValidationIdentityService
from src.platform_api.services.validation_v2_service import ValidationV2Service
from src.platform_api.state_store import InMemoryStateStore

ValidationProfile = Literal["FAST", "STANDARD", "EXPERT"]


def _policy_payload(*, profile: ValidationProfile) -> dict[str, object]:
    return {
        "profile": profile,
        "blockMergeOnFail": True,
        "blockReleaseOnFail": True,
        "blockMergeOnAgentFail": True,
        "blockReleaseOnAgentFail": False,
        "requireTraderReview": False,
        "hardFailOnMissingIndicators": True,
        "failClosedOnEvidenceUnavailable": True,
    }


def _run_payload(*, profile: ValidationProfile, backtest_ref: str) -> CreateValidationRunRequest:
    return CreateValidationRunRequest.model_validate(
        {
            "strategyId": "strat-001",
            "providerRefId": "lona-strategy-123",
            "prompt": "CI replay gate check run.",
            "requestedIndicators": ["zigzag", "ema"],
            "datasetIds": ["dataset-btc-1h-2025"],
            "backtestReportRef": backtest_ref,
            "policy": _policy_payload(profile=profile),
        }
    )


async def compute_release_gate_replay(
    *,
    baseline_profile: ValidationProfile = "STANDARD",
    candidate_profile: ValidationProfile = "STANDARD",
) -> ValidationRegressionReplay:
    store = InMemoryStateStore()
    identity_service = ValidationIdentityService(store=store)
    service = ValidationV2Service(store=store, identity_service=identity_service)
    context = RequestContext(
        request_id="req-validation-release-gate",
        tenant_id="tenant-validation-release-gate",
        user_id="user-validation-release-gate",
    )

    baseline_run_response = await service.create_validation_run(
        request=_run_payload(
            profile=baseline_profile,
            backtest_ref="blob://validation/release-gate/baseline-backtest-report.json",
        ),
        context=context,
        idempotency_key="idem-validation-release-gate-baseline-run",
    )
    baseline_run_id = baseline_run_response.run.id

    baseline_response = await service.create_validation_baseline(
        request=CreateValidationBaselineRequest.model_validate(
            {
                "runId": baseline_run_id,
                "name": "release-gate-baseline",
                "notes": "Generated by release preflight replay gate check.",
            }
        ),
        context=context,
        idempotency_key="idem-validation-release-gate-baseline",
    )

    candidate_run_response = await service.create_validation_run(
        request=_run_payload(
            profile=candidate_profile,
            backtest_ref="blob://validation/release-gate/candidate-backtest-report.json",
        ),
        context=context,
        idempotency_key="idem-validation-release-gate-candidate-run",
    )

    replay_response = await service.replay_validation_regression(
        request=CreateValidationRegressionReplayRequest.model_validate(
            {
                "baselineId": baseline_response.baseline.id,
                "candidateRunId": candidate_run_response.run.id,
            }
        ),
        context=context,
        idempotency_key="idem-validation-release-gate-replay",
    )
    return replay_response.replay


def _is_gate_blocked(*, replay: ValidationRegressionReplay) -> bool:
    return (
        replay.mergeBlocked
        or replay.releaseBlocked
        or replay.mergeGateStatus != "pass"
        or replay.releaseGateStatus != "pass"
    )


def _utc_now_rfc3339() -> str:
    return datetime.now(tz=timezone.utc).isoformat().replace("+00:00", "Z")


def build_release_gate_report(*, replay: ValidationRegressionReplay) -> dict[str, object]:
    gate_blocked = _is_gate_blocked(replay=replay)
    return {
        "schemaVersion": "validation-replay-gate-report.v1",
        "generatedAt": _utc_now_rfc3339(),
        "gateStatus": "blocked" if gate_blocked else "pass",
        "gate": replay.model_dump(mode="json"),
        "evidenceRefs": [
            {"kind": "validation_replay_id", "ref": replay.id},
            {"kind": "validation_baseline_id", "ref": replay.baselineId},
            {"kind": "validation_candidate_run_id", "ref": replay.candidateRunId},
        ],
    }


def run_release_gate_check(
    *,
    baseline_profile: ValidationProfile = "STANDARD",
    candidate_profile: ValidationProfile = "STANDARD",
    output_path: str | None = None,
) -> int:
    replay = asyncio.run(
        compute_release_gate_replay(
            baseline_profile=baseline_profile,
            candidate_profile=candidate_profile,
        )
    )
    report = build_release_gate_report(replay=replay)
    output = json.dumps(report, sort_keys=True)
    print(output)

    if output_path is not None:
        destination = Path(output_path)
        destination.parent.mkdir(parents=True, exist_ok=True)
        destination.write_text(f"{output}\n", encoding="utf-8")

    gate_blocked = _is_gate_blocked(replay=replay)
    if gate_blocked:
        print(
            (
                "Release gate blocked by replay outcome: "
                f"mergeBlocked={replay.mergeBlocked}, releaseBlocked={replay.releaseBlocked}, "
                f"mergeGateStatus={replay.mergeGateStatus}, releaseGateStatus={replay.releaseGateStatus}"
            ),
            file=sys.stderr,
        )
        return 1
    return 0


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--baseline-profile",
        choices=["FAST", "STANDARD", "EXPERT"],
        default="STANDARD",
        help="Baseline run policy profile for replay check.",
    )
    parser.add_argument(
        "--candidate-profile",
        choices=["FAST", "STANDARD", "EXPERT"],
        default="STANDARD",
        help="Candidate run policy profile for replay check.",
    )
    parser.add_argument(
        "--output",
        default=None,
        help="Optional path to write replay gate JSON output.",
    )
    args = parser.parse_args(argv)

    return run_release_gate_check(
        baseline_profile=args.baseline_profile,
        candidate_profile=args.candidate_profile,
        output_path=args.output,
    )


if __name__ == "__main__":
    raise SystemExit(main())

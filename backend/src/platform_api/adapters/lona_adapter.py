"""Lona adapter boundary and baseline implementation."""

from __future__ import annotations

from dataclasses import dataclass
from datetime import UTC, datetime
from typing import Protocol

from src.schemas.lona import LonaBacktestRequest, LonaSimulationParameters
from src.services.lona_client import LonaClient, LonaClientError


class AdapterError(Exception):
    """Typed adapter failure used by services to map provider errors."""

    def __init__(self, message: str, *, code: str = "ADAPTER_ERROR", status_code: int = 502) -> None:
        super().__init__(message)
        self.code = code
        self.status_code = status_code


@dataclass
class LonaBacktestReport:
    status: str
    metrics: dict[str, float] | None = None
    error: str | None = None


class LonaAdapter(Protocol):
    """Provider-facing contract for Lona operations."""

    async def create_strategy_from_description(
        self,
        *,
        name: str | None,
        description: str,
        provider: str,
        tenant_id: str,
        user_id: str,
    ) -> dict[str, str | None]:
        ...

    async def run_backtest(
        self,
        *,
        provider_ref_id: str,
        data_ids: list[str],
        start_date: str,
        end_date: str,
        initial_cash: float,
        tenant_id: str,
        user_id: str,
    ) -> dict[str, str]:
        ...

    async def get_backtest_report(
        self,
        *,
        provider_report_id: str,
        tenant_id: str,
        user_id: str,
    ) -> LonaBacktestReport:
        ...

    async def list_symbols(
        self,
        *,
        is_global: bool,
        limit: int,
        tenant_id: str,
        user_id: str,
    ) -> list[dict[str, str]]:
        ...

    async def download_market_data(
        self,
        *,
        symbol: str,
        interval: str,
        start_date: str,
        end_date: str,
        tenant_id: str,
        user_id: str,
    ) -> dict[str, str]:
        ...


class LonaAdapterBaseline:
    """Baseline Lona adapter.

    By default this adapter runs in synthetic mode to keep Gate2 tests deterministic
    without requiring external network/provider dependencies.
    """

    def __init__(self, *, use_remote_provider: bool = False) -> None:
        self._use_remote_provider = use_remote_provider
        self._report_counter = 1
        self._reports: dict[str, LonaBacktestReport] = {}

    async def create_strategy_from_description(
        self,
        *,
        name: str | None,
        description: str,
        provider: str,
        tenant_id: str,
        user_id: str,
    ) -> dict[str, str | None]:
        if not self._use_remote_provider:
            provider_ref_id = f"lona-strategy-{abs(hash((name or '', description, tenant_id, user_id))) % 100000}"
            return {
                "providerRefId": provider_ref_id,
                "name": name or "Generated Strategy",
                "explanation": "Synthetic strategy generated by LonaAdapter baseline.",
            }

        try:
            async with LonaClient() as client:
                result = await client.create_strategy_from_description(
                    description=description,
                    name=name,
                    provider=provider,
                )
        except LonaClientError as exc:
            raise AdapterError(str(exc), code="LONA_STRATEGY_CREATE_FAILED", status_code=exc.status_code or 502)

        return {
            "providerRefId": result.strategy_id,
            "name": result.name,
            "explanation": result.explanation,
        }

    async def run_backtest(
        self,
        *,
        provider_ref_id: str,
        data_ids: list[str],
        start_date: str,
        end_date: str,
        initial_cash: float,
        tenant_id: str,
        user_id: str,
    ) -> dict[str, str]:
        if not self._use_remote_provider:
            report_id = f"lona-report-{self._report_counter:04d}"
            self._report_counter += 1
            self._reports[report_id] = LonaBacktestReport(
                status="completed",
                metrics={
                    "sharpeRatio": 1.12,
                    "maxDrawdownPct": 11.0,
                    "winRatePct": 54.1,
                    "totalReturnPct": 18.4,
                },
            )
            return {"providerReportId": report_id}

        try:
            async with LonaClient() as client:
                result = await client.run_backtest(
                    LonaBacktestRequest(
                        strategy_id=provider_ref_id,
                        data_ids=data_ids,
                        start_date=start_date,
                        end_date=end_date,
                        simulation_parameters=LonaSimulationParameters(initial_cash=initial_cash),
                    )
                )
        except LonaClientError as exc:
            raise AdapterError(str(exc), code="LONA_BACKTEST_CREATE_FAILED", status_code=exc.status_code or 502)

        return {"providerReportId": result.report_id}

    async def get_backtest_report(
        self,
        *,
        provider_report_id: str,
        tenant_id: str,
        user_id: str,
    ) -> LonaBacktestReport:
        if not self._use_remote_provider:
            report = self._reports.get(provider_report_id)
            if report is None:
                return LonaBacktestReport(status="queued")
            return report

        try:
            async with LonaClient() as client:
                status = await client.get_report_status(provider_report_id)
                mapped_status = self._map_report_status(status.status)
                if mapped_status in ("queued", "running"):
                    return LonaBacktestReport(status=mapped_status)

                report = await client.get_report(provider_report_id)
                metrics = self._map_report_metrics(report.total_stats or {})
                return LonaBacktestReport(
                    status=mapped_status,
                    metrics=metrics,
                    error=report.error,
                )
        except LonaClientError as exc:
            raise AdapterError(str(exc), code="LONA_BACKTEST_REPORT_FAILED", status_code=exc.status_code or 502)

    async def list_symbols(
        self,
        *,
        is_global: bool,
        limit: int,
        tenant_id: str,
        user_id: str,
    ) -> list[dict[str, str]]:
        if not self._use_remote_provider:
            return [{"id": "lona-symbol-001", "name": "BTCUSDT"}, {"id": "lona-symbol-002", "name": "ETHUSDT"}][
                : max(1, limit)
            ]

        try:
            async with LonaClient() as client:
                symbols = await client.list_symbols(is_global=is_global, limit=limit)
        except LonaClientError as exc:
            raise AdapterError(str(exc), code="LONA_LIST_SYMBOLS_FAILED", status_code=exc.status_code or 502)

        return [{"id": item.id, "name": item.name} for item in symbols]

    async def download_market_data(
        self,
        *,
        symbol: str,
        interval: str,
        start_date: str,
        end_date: str,
        tenant_id: str,
        user_id: str,
    ) -> dict[str, str]:
        if not self._use_remote_provider:
            token = datetime.now(tz=UTC).strftime("%Y%m%d%H%M%S")
            return {"dataId": f"dataset-{symbol.lower()}-{interval}-{token}"}

        try:
            async with LonaClient() as client:
                result = await client.download_market_data(
                    symbol=symbol,
                    interval=interval,
                    start_date=start_date,
                    end_date=end_date,
                )
        except LonaClientError as exc:
            raise AdapterError(str(exc), code="LONA_MARKET_DATA_DOWNLOAD_FAILED", status_code=exc.status_code or 502)

        return {"dataId": result.id}

    @staticmethod
    def _map_report_status(status: str) -> str:
        normalized = status.lower()
        if normalized in {"pending", "queued"}:
            return "queued"
        if normalized in {"executing", "processing", "running"}:
            return "running"
        if normalized == "completed":
            return "completed"
        if normalized == "failed":
            return "failed"
        if normalized == "cancelled":
            return "cancelled"
        return "running"

    @staticmethod
    def _map_report_metrics(raw: dict[str, object]) -> dict[str, float]:
        def _value(*names: str) -> float | None:
            for name in names:
                value = raw.get(name)
                if isinstance(value, (int, float)):
                    return float(value)
            return None

        metrics = {
            "sharpeRatio": _value("sharpeRatio", "sharpe_ratio"),
            "maxDrawdownPct": _value("maxDrawdownPct", "max_drawdown_pct", "max_drawdown"),
            "winRatePct": _value("winRatePct", "win_rate_pct", "win_rate"),
            "totalReturnPct": _value("totalReturnPct", "total_return_pct", "total_return"),
        }
        return {key: value for key, value in metrics.items() if value is not None}

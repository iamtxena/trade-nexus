name: review-governance

on:
  pull_request:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review
      - review_requested
    paths:
      - "backend/src/platform_api/**"
      - "backend/tests/contracts/**"
      - "docs/architecture/**"
      - "docs/portal/**"
      - ".github/workflows/**"
      - ".github/PULL_REQUEST_TEMPLATE.md"
  pull_request_review:
    types:
      - submitted
      - edited
      - dismissed
  pull_request_review_thread:
    types:
      - resolved
      - unresolved

jobs:
  review-governance:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      checks: read
    steps:
      - name: Enforce review gate sequencing
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;
            const requiredBotReviewActors = ["cursor", "greptile-apps"];

            async function listAllChangedFiles() {
              const files = [];
              for await (const page of github.paginate.iterator(
                github.rest.pulls.listFiles,
                {
                  owner,
                  repo,
                  pull_number: prNumber,
                  per_page: 100,
                },
              )) {
                files.push(...page.data.map((item) => item.filename));
              }
              return files;
            }

            async function getReviewThreads() {
              const threads = [];
              let cursor = null;
              let hasNextPage = true;
              while (hasNextPage) {
                const response = await github.graphql(
                  `
                  query($owner: String!, $repo: String!, $prNumber: Int!, $cursor: String) {
                    repository(owner: $owner, name: $repo) {
                      pullRequest(number: $prNumber) {
                        reviewThreads(first: 100, after: $cursor) {
                          pageInfo {
                            hasNextPage
                            endCursor
                          }
                          nodes {
                            isResolved
                            comments(first: 10) {
                              nodes {
                                url
                                author {
                                  login
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  `,
                  {
                    owner,
                    repo,
                    prNumber,
                    cursor,
                  },
                );
                const threadConnection = response.repository.pullRequest.reviewThreads;
                threads.push(...threadConnection.nodes);
                hasNextPage = threadConnection.pageInfo.hasNextPage;
                cursor = threadConnection.pageInfo.endCursor;
              }
              return threads;
            }

            async function getReviewActors() {
              const response = await github.graphql(
                `
                query($owner: String!, $repo: String!, $prNumber: Int!) {
                  repository(owner: $owner, name: $repo) {
                    pullRequest(number: $prNumber) {
                      reviews(first: 100) {
                        nodes {
                          author {
                            login
                          }
                          state
                        }
                      }
                    }
                  }
                }
                `,
                {
                  owner,
                  repo,
                  prNumber,
                },
              );
              return response.repository.pullRequest.reviews.nodes
                .filter((review) => review.author && review.author.login)
                .map((review) => String(review.author.login).toLowerCase());
            }

            const changedFiles = await listAllChangedFiles();
            const requiresBotReviews = changedFiles.some((filename) =>
              filename.startsWith("backend/src/platform_api/") ||
              filename.startsWith("backend/tests/contracts/") ||
              filename === ".github/workflows/contracts-governance.yml",
            );

            const reviewThreads = await getReviewThreads();
            const unresolvedThreads = reviewThreads.filter((thread) => !thread.isResolved);
            if (unresolvedThreads.length > 0) {
              const unresolvedUrls = unresolvedThreads
                .map((thread) => thread.comments.nodes[0]?.url)
                .filter(Boolean)
                .slice(0, 10);
              core.setFailed(
                `Unresolved review threads detected (${unresolvedThreads.length}). Resolve all threads before merge. ${unresolvedUrls.join(" ")}`,
              );
              return;
            }

            if (requiresBotReviews) {
              const actors = await getReviewActors();
              const missingActors = requiredBotReviewActors.filter(
                (requiredActor) => !actors.includes(requiredActor),
              );
              if (missingActors.length > 0) {
                core.setFailed(
                  `Missing required bot review submissions: ${missingActors.join(", ")}.`,
                );
                return;
              }
            }

            core.info("Review governance checks passed.");
